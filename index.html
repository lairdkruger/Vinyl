<html>
    <head>
        <meta charset="utf-8">
        <title>Vinyl Visualizer</title>
        
        <script src="src/canvas.js"></script>
        <script src="src/creative_coding.js"></script>
        <script src="src/mic.js"></script>
        
    </head>
    
    <body>
        
        <script>
            //create canvas
            var ctx = createCanvas("canvas1");
            
            //double click fullscreen event listener
            //Double Click to go FULLSCREEN
            function getreqfullscreen(){
                var root = document.documentElement
                return root.requestFullscreen || root.webkitRequestFullscreen || root.mozRequestFullScreen || root.msRequestFullscreen
            }
            
            canvas.addEventListener('dblclick', function(){ 

                //usage: getreqfullscreen().call(targetelement) // open full screen on targetelement
            
                var globalreqfullscreen = getreqfullscreen() // get supported version of requestFullscreen()
            
                globalreqfullscreen.call(document.documentElement);
            });
            
            document.addEventListener('keypress', function (e) {
                if (e.keyCode == 49) {
                    //1: basic black and white
                    mode = "standard";
                    line_color = rgb(255, 255, 255);
                } else if (e.keyCode == 50) {
                    //2: lit
                    mode = "lit";
                } else if (e.keyCode == 51) {
                    //3: lit II
                    mode = "lit II";
                }
                
            }, false);
            
            
            //set to 128 for digitised effect, otherwise 512 is smooth
            var mic = new Microphone(256);
            
            //number of lines of symmetry
            var symmetry_num = 2;
            
            //particles
            var particles = [];
            var num_particles = 80;
            var num_rings = 80;
            var max_radius = h / 3;
            var gap = max_radius / num_rings;
            var waveform_array = [];
            var waveform_intensity = h / 1.5;
            var explode = 1;
            
            //color setup
            var hue = 0;
            var line_color = rgb(255, 255, 255);
            var color_array = [];
            
            //color modes: standard, palette, lit, lit II, lit III
            var mode = "standard";
        
            //add a number of particles to particles
            for (i = 0; i < num_rings; i++) {
                particles.push([]);
                color_array.push([]);
                for (j = 0; j < num_particles; j++) {
                    addParticle(i, j);
                }
            }
            
            
            function addParticle(_i, j) {
                var _angle = radians(distributeAngles(j, num_particles)) + 1.62;
                var particle = {
                    x: 0,
                    y: 0,
                    angle: _angle,
                    radius: max_radius - (gap * i),
                }
                
                particles[i].push(particle);
            }
            
            console.log(particles);
            
            
            function drawParticles(explode) {
                //calculate first ring shape using mic.js
                for (j = 0; j < symmetry_num; j++) {
                    for (i = 0; i < num_particles / symmetry_num; i++) {
                        particle_id = (num_particles / symmetry_num) * j;
                        waveform = mic.mapWaveform(i, num_particles / symmetry_num, 1, waveform_intensity);
                        
                        waveform_array[i] = waveform;
                        
                        if (j % 2 == 0) {
                            //counts downwards from particle_id if j is even (for symmetry)
                            particle = particle_id + (num_particles / symmetry_num) - i - 1;
                            p = particles[0][particle];
                        } else {
                            //counts upwards from particle_id is j is odd (for symmetry)
                            p = particles[0][particle_id + i];
                        }
                        
                        p.x = w/2 + Math.cos(p.angle) * (p.radius * waveform * explode);
                        p.y = h/2 + Math.sin(p.angle) * (p.radius * waveform * explode);
                    }
                }
                    
                //use waveform_array to calculate other rings shapes
                for (k = 1; k < num_rings; k++) {
                    for (j = 0; j < symmetry_num; j++) {
                        for (i = 0; i < num_particles / symmetry_num; i++) {
                            particle_id = (num_particles / symmetry_num) * j;
                            
                            if (j % 2 == 0) {
                                //counts downwards from particle_id if j is even (for symmetry)
                                particle = particle_id + (num_particles / symmetry_num) - i - 1;
                                p = particles[k][particle];
                            } else {
                                //counts upwards from particle_id is j is odd (for symmetry)
                                p = particles[k][particle_id + i];
                            }
                            
                            p.x = w/2 + Math.cos(p.angle) * (p.radius * waveform_array[i] * explode);
                            p.y = h/2 + Math.sin(p.angle) * (p.radius * waveform_array[i] * explode);
                        }
                    }
                }
            }
            
            
            function drawConnections() {
                
                if (mode == "lit II") {
                    volume = mic.getRMS(mic.spectrum);
                    lightness = map(volume, 0, 100, 40, 70, true);
                    add = map(volume, 0, 100, 0, 2.5) ** 3;

                    if (hue == 360) {
                        hue = 0;
                    } else {
                        hue += add;
                    }
                    
                    color_array[num_rings] = hsl(hue, 70, lightness);
                    
                    for (k = 0; k < num_rings; k++) {
                        color_array[k] = color_array[k + 1];
                    }
                }
                
                
                for (j = 0; j < num_rings; j++) {
                    if (mode == "lit II") {
                        ctx.strokeStyle = color_array[j];
                    }
                    
                    for (i = 0; i < num_particles - 1; i++) {
                        p1 = particles[j][i];
                        p2 = particles[j][i + 1];
                        ctx.line(p1.x, p1.y, p2.x, p2.y);
                    }

                    p1 = particles[j][0];
                    p2 = particles[j][num_particles - 1];
                    ctx.line(p1.x, p1.y, p2.x, p2.y);
                }
            }
                
            
            ctx.lineWidth = 1.5;
            
            
            //requests animation frame
            function draw() {
                frameRate = 120;
                volume = mic.getRMS(mic.spectrum);
                peak_vol = mic.peak_volume;
                
                ctx.background(0, map(volume, 0, 100, 0.35, 0.01));
                
                drawParticles(explode);
                drawConnections();
                
                ctx.fillStyle = rgb(255);
                ctx.fillEllipse(w/2, h/2, 2, 2);
                
                if (mode == "standard") {
                    ctx.strokeStyle = line_color;
                } else if (mode == "lit") {
                    lightness = map(volume, 0, 100, 40, 70, true);
                    add = map(volume, 0, 100, 0, 3.5) ** 3;

                    if (volume > peak_vol - 20) {
                        explode = 2;
                        hue = randomInt(0, 360);
                    } else {
                        if (hue == 360) {
                            hue = 0;
                        } else {
                            hue += add;
                        }
                    }
                    ctx.strokeStyle = hsl(hue, 70, lightness);
                }
                
                if (volume < peak_vol - 20) {
                    symmetry_num = 2;
                    explode = 1;
                } else if (volume >= peak_vol - 20) {
                    symmetry_num = 4;
                    explode = 1;
                }
                
            }
            
        </script>
    </body>
</html>